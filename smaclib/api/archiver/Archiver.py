#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import smaclib.api.module.Module
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(smaclib.api.module.Module.Iface):
  def request_upload_slot():
    """
    Creates an upload slot for a general file. Returns an address valid for
    a single file upload.

    An uploaded file may then be processed using an archive_* method and
    the ID of the uploaded file. The ID of the uploaded file can always be
    inferred from the upload URI.

    The default implementation provides FTP based slots, where the URI
    is a complete FTP address to a directory where a file shall be
    uploaded; in this case the upload ID is the FTP user and the remote
    filename is not relevant.
    """
    pass

  def abort_upload(upload_id):
    """
    Aborts a not yet processed upload.

    Parameters:
     - upload_id
    """
    pass

  def archive_upload(talk_id, upload_id, file_info):
    """
    Archives (and thus confirms) a successfull upload.

    The file_info struct has to contain at least the values for the mime
    type and any additional metadata as required by the implementation.

    Parameters:
     - talk_id
     - upload_id
     - file_info
    """
    pass

  def encode_video(video_id, encoding_info):
    """
    Encodes a video stream from its original format to the given one if a
    suitable encoder is available.

    The EncodingInfo struct carries informations about the output format,
    such as encoding mimetype and bitrates for both audio and video.

    The video and audio bitrates can be a name of a preset to use (such as
    default, speaker, slide,..) or a literal value (such as 64k, 150k,...).

    @TODO: Merge this method into the convert_asset method and automatically
           resolve to this one.

    Parameters:
     - video_id
     - encoding_info
    """
    pass

  def convert_asset(document_id, mimetype, conversion_info):
    """
    Converts a document from its original format to the format implied by
    the given mimetype.

    This method should be general enough to be able to convert between
    arbitrary tuples of formats, as implemented by the underlying module.

    The conversion_info dictionary contains converter dependent attributes,
    refer to the actual module implementation for further details about the
    directives required by each converter.

    Parameters:
     - document_id
     - mimetype
     - conversion_info
    """
    pass


class Client(smaclib.api.module.Module.Client):
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    smaclib.api.module.Module.Client.__init__(self, transport, oprot_factory)

  def request_upload_slot(self, ):
    """
    Creates an upload slot for a general file. Returns an address valid for
    a single file upload.

    An uploaded file may then be processed using an archive_* method and
    the ID of the uploaded file. The ID of the uploaded file can always be
    inferred from the upload URI.

    The default implementation provides FTP based slots, where the URI
    is a complete FTP address to a directory where a file shall be
    uploaded; in this case the upload ID is the FTP user and the remote
    filename is not relevant.
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_request_upload_slot()
    return d

  def send_request_upload_slot(self, ):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('request_upload_slot', TMessageType.CALL, self._seqid)
    args = request_upload_slot_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_request_upload_slot(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = request_upload_slot_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "request_upload_slot failed: unknown result"))

  def abort_upload(self, upload_id):
    """
    Aborts a not yet processed upload.

    Parameters:
     - upload_id
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_abort_upload(upload_id)
    return d

  def send_abort_upload(self, upload_id):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('abort_upload', TMessageType.CALL, self._seqid)
    args = abort_upload_args()
    args.upload_id = upload_id
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_abort_upload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = abort_upload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def archive_upload(self, talk_id, upload_id, file_info):
    """
    Archives (and thus confirms) a successfull upload.

    The file_info struct has to contain at least the values for the mime
    type and any additional metadata as required by the implementation.

    Parameters:
     - talk_id
     - upload_id
     - file_info
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_archive_upload(talk_id, upload_id, file_info)
    return d

  def send_archive_upload(self, talk_id, upload_id, file_info):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('archive_upload', TMessageType.CALL, self._seqid)
    args = archive_upload_args()
    args.talk_id = talk_id
    args.upload_id = upload_id
    args.file_info = file_info
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_archive_upload(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = archive_upload_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      return d.callback(result.success)
    if result.upload_err != None:
      return d.errback(result.upload_err)
    if result.mime_err != None:
      return d.errback(result.mime_err)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "archive_upload failed: unknown result"))

  def encode_video(self, video_id, encoding_info):
    """
    Encodes a video stream from its original format to the given one if a
    suitable encoder is available.

    The EncodingInfo struct carries informations about the output format,
    such as encoding mimetype and bitrates for both audio and video.

    The video and audio bitrates can be a name of a preset to use (such as
    default, speaker, slide,..) or a literal value (such as 64k, 150k,...).

    @TODO: Merge this method into the convert_asset method and automatically
           resolve to this one.

    Parameters:
     - video_id
     - encoding_info
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_encode_video(video_id, encoding_info)
    return d

  def send_encode_video(self, video_id, encoding_info):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('encode_video', TMessageType.CALL, self._seqid)
    args = encode_video_args()
    args.video_id = video_id
    args.encoding_info = encoding_info
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_encode_video(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = encode_video_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      return d.callback(result.success)
    if result.asset_err != None:
      return d.errback(result.asset_err)
    if result.format_err != None:
      return d.errback(result.format_err)
    if result.mime_err != None:
      return d.errback(result.mime_err)
    if result.encoder_err != None:
      return d.errback(result.encoder_err)
    if result.bitrate_err != None:
      return d.errback(result.bitrate_err)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "encode_video failed: unknown result"))

  def convert_asset(self, document_id, mimetype, conversion_info):
    """
    Converts a document from its original format to the format implied by
    the given mimetype.

    This method should be general enough to be able to convert between
    arbitrary tuples of formats, as implemented by the underlying module.

    The conversion_info dictionary contains converter dependent attributes,
    refer to the actual module implementation for further details about the
    directives required by each converter.

    Parameters:
     - document_id
     - mimetype
     - conversion_info
    """
    self._seqid += 1
    d = self._reqs[self._seqid] = defer.Deferred()
    self.send_convert_asset(document_id, mimetype, conversion_info)
    return d

  def send_convert_asset(self, document_id, mimetype, conversion_info):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('convert_asset', TMessageType.CALL, self._seqid)
    args = convert_asset_args()
    args.document_id = document_id
    args.mimetype = mimetype
    args.conversion_info = conversion_info
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_convert_asset(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = convert_asset_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      return d.callback(result.success)
    if result.asset_err != None:
      return d.errback(result.asset_err)
    if result.info_err != None:
      return d.errback(result.info_err)
    if result.converter_err != None:
      return d.errback(result.converter_err)
    if result.mime_err != None:
      return d.errback(result.mime_err)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "convert_asset failed: unknown result"))


class Processor(smaclib.api.module.Module.Processor, TProcessor):
  implements(Iface)

  def __init__(self, handler):
    smaclib.api.module.Module.Processor.__init__(self, Iface(handler))
    self._processMap["request_upload_slot"] = Processor.process_request_upload_slot
    self._processMap["abort_upload"] = Processor.process_abort_upload
    self._processMap["archive_upload"] = Processor.process_archive_upload
    self._processMap["encode_video"] = Processor.process_encode_video
    self._processMap["convert_asset"] = Processor.process_convert_asset

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_request_upload_slot(self, seqid, iprot, oprot):
    args = request_upload_slot_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = request_upload_slot_result()
    d = defer.maybeDeferred(self._handler.request_upload_slot, )
    d.addCallback(self.write_results_success_request_upload_slot, result, seqid, oprot)
    return d

  def write_results_success_request_upload_slot(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("request_upload_slot", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_abort_upload(self, seqid, iprot, oprot):
    args = abort_upload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abort_upload_result()
    d = defer.maybeDeferred(self._handler.abort_upload, args.upload_id)
    d.addCallback(self.write_results_success_abort_upload, result, seqid, oprot)
    return d

  def write_results_success_abort_upload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("abort_upload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_archive_upload(self, seqid, iprot, oprot):
    args = archive_upload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = archive_upload_result()
    d = defer.maybeDeferred(self._handler.archive_upload, args.talk_id, args.upload_id, args.file_info)
    d.addCallback(self.write_results_success_archive_upload, result, seqid, oprot)
    d.addErrback(self.write_results_exception_archive_upload, result, seqid, oprot)
    return d

  def write_results_success_archive_upload(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("archive_upload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_archive_upload(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except smaclib.api.errors.ttypes.InvalidUploadID, upload_err:
      result.upload_err = upload_err
    except smaclib.api.errors.ttypes.UnknownMimetype, mime_err:
      result.mime_err = mime_err
    oprot.writeMessageBegin("archive_upload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_encode_video(self, seqid, iprot, oprot):
    args = encode_video_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = encode_video_result()
    d = defer.maybeDeferred(self._handler.encode_video, args.video_id, args.encoding_info)
    d.addCallback(self.write_results_success_encode_video, result, seqid, oprot)
    d.addErrback(self.write_results_exception_encode_video, result, seqid, oprot)
    return d

  def write_results_success_encode_video(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("encode_video", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_encode_video(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except smaclib.api.errors.ttypes.AssetNotFound, asset_err:
      result.asset_err = asset_err
    except smaclib.api.errors.ttypes.InvalidFormat, format_err:
      result.format_err = format_err
    except smaclib.api.errors.ttypes.UnknownMimetype, mime_err:
      result.mime_err = mime_err
    except smaclib.api.errors.ttypes.NoSuitableEncoder, encoder_err:
      result.encoder_err = encoder_err
    except smaclib.api.errors.ttypes.InvalidBitrate, bitrate_err:
      result.bitrate_err = bitrate_err
    oprot.writeMessageBegin("encode_video", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_convert_asset(self, seqid, iprot, oprot):
    args = convert_asset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = convert_asset_result()
    d = defer.maybeDeferred(self._handler.convert_asset, args.document_id, args.mimetype, args.conversion_info)
    d.addCallback(self.write_results_success_convert_asset, result, seqid, oprot)
    d.addErrback(self.write_results_exception_convert_asset, result, seqid, oprot)
    return d

  def write_results_success_convert_asset(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("convert_asset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_convert_asset(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except smaclib.api.errors.ttypes.AssetNotFound, asset_err:
      result.asset_err = asset_err
    except smaclib.api.errors.ttypes.InvalidConversionInfo, info_err:
      result.info_err = info_err
    except smaclib.api.errors.ttypes.UnsupportedConversion, converter_err:
      result.converter_err = converter_err
    except smaclib.api.errors.ttypes.UnknownMimetype, mime_err:
      result.mime_err = mime_err
    oprot.writeMessageBegin("convert_asset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class request_upload_slot_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('request_upload_slot_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class request_upload_slot_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('request_upload_slot_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_upload_args:
  """
  Attributes:
   - upload_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'upload_id', None, None, ), # 1
  )

  def __init__(self, upload_id=None,):
    self.upload_id = upload_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.upload_id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_upload_args')
    if self.upload_id != None:
      oprot.writeFieldBegin('upload_id', TType.STRING, 1)
      oprot.writeString(self.upload_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_upload_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_upload_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class archive_upload_args:
  """
  Attributes:
   - talk_id
   - upload_id
   - file_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'talk_id', None, None, ), # 1
    (2, TType.STRING, 'upload_id', None, None, ), # 2
    (3, TType.STRUCT, 'file_info', (smaclib.api.ttypes.FileInfo, smaclib.api.ttypes.FileInfo.thrift_spec), None, ), # 3
  )

  def __init__(self, talk_id=None, upload_id=None, file_info=None,):
    self.talk_id = talk_id
    self.upload_id = upload_id
    self.file_info = file_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.talk_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.upload_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.file_info = smaclib.api.ttypes.FileInfo()
          self.file_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('archive_upload_args')
    if self.talk_id != None:
      oprot.writeFieldBegin('talk_id', TType.STRING, 1)
      oprot.writeString(self.talk_id)
      oprot.writeFieldEnd()
    if self.upload_id != None:
      oprot.writeFieldBegin('upload_id', TType.STRING, 2)
      oprot.writeString(self.upload_id)
      oprot.writeFieldEnd()
    if self.file_info != None:
      oprot.writeFieldBegin('file_info', TType.STRUCT, 3)
      self.file_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class archive_upload_result:
  """
  Attributes:
   - success
   - upload_err
   - mime_err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'upload_err', (smaclib.api.errors.ttypes.InvalidUploadID, smaclib.api.errors.ttypes.InvalidUploadID.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'mime_err', (smaclib.api.errors.ttypes.UnknownMimetype, smaclib.api.errors.ttypes.UnknownMimetype.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, upload_err=None, mime_err=None,):
    self.success = success
    self.upload_err = upload_err
    self.mime_err = mime_err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.upload_err = smaclib.api.errors.ttypes.InvalidUploadID()
          self.upload_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mime_err = smaclib.api.errors.ttypes.UnknownMimetype()
          self.mime_err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('archive_upload_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.upload_err != None:
      oprot.writeFieldBegin('upload_err', TType.STRUCT, 1)
      self.upload_err.write(oprot)
      oprot.writeFieldEnd()
    if self.mime_err != None:
      oprot.writeFieldBegin('mime_err', TType.STRUCT, 2)
      self.mime_err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class encode_video_args:
  """
  Attributes:
   - video_id
   - encoding_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'video_id', None, None, ), # 1
    (2, TType.STRUCT, 'encoding_info', (smaclib.api.ttypes.EncodingInfo, smaclib.api.ttypes.EncodingInfo.thrift_spec), None, ), # 2
  )

  def __init__(self, video_id=None, encoding_info=None,):
    self.video_id = video_id
    self.encoding_info = encoding_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.video_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.encoding_info = smaclib.api.ttypes.EncodingInfo()
          self.encoding_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('encode_video_args')
    if self.video_id != None:
      oprot.writeFieldBegin('video_id', TType.STRING, 1)
      oprot.writeString(self.video_id)
      oprot.writeFieldEnd()
    if self.encoding_info != None:
      oprot.writeFieldBegin('encoding_info', TType.STRUCT, 2)
      self.encoding_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class encode_video_result:
  """
  Attributes:
   - success
   - asset_err
   - format_err
   - mime_err
   - encoder_err
   - bitrate_err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'asset_err', (smaclib.api.errors.ttypes.AssetNotFound, smaclib.api.errors.ttypes.AssetNotFound.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'format_err', (smaclib.api.errors.ttypes.InvalidFormat, smaclib.api.errors.ttypes.InvalidFormat.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'mime_err', (smaclib.api.errors.ttypes.UnknownMimetype, smaclib.api.errors.ttypes.UnknownMimetype.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'encoder_err', (smaclib.api.errors.ttypes.NoSuitableEncoder, smaclib.api.errors.ttypes.NoSuitableEncoder.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'bitrate_err', (smaclib.api.errors.ttypes.InvalidBitrate, smaclib.api.errors.ttypes.InvalidBitrate.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, asset_err=None, format_err=None, mime_err=None, encoder_err=None, bitrate_err=None,):
    self.success = success
    self.asset_err = asset_err
    self.format_err = format_err
    self.mime_err = mime_err
    self.encoder_err = encoder_err
    self.bitrate_err = bitrate_err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.asset_err = smaclib.api.errors.ttypes.AssetNotFound()
          self.asset_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.format_err = smaclib.api.errors.ttypes.InvalidFormat()
          self.format_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.mime_err = smaclib.api.errors.ttypes.UnknownMimetype()
          self.mime_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.encoder_err = smaclib.api.errors.ttypes.NoSuitableEncoder()
          self.encoder_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.bitrate_err = smaclib.api.errors.ttypes.InvalidBitrate()
          self.bitrate_err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('encode_video_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.asset_err != None:
      oprot.writeFieldBegin('asset_err', TType.STRUCT, 1)
      self.asset_err.write(oprot)
      oprot.writeFieldEnd()
    if self.format_err != None:
      oprot.writeFieldBegin('format_err', TType.STRUCT, 2)
      self.format_err.write(oprot)
      oprot.writeFieldEnd()
    if self.mime_err != None:
      oprot.writeFieldBegin('mime_err', TType.STRUCT, 3)
      self.mime_err.write(oprot)
      oprot.writeFieldEnd()
    if self.encoder_err != None:
      oprot.writeFieldBegin('encoder_err', TType.STRUCT, 4)
      self.encoder_err.write(oprot)
      oprot.writeFieldEnd()
    if self.bitrate_err != None:
      oprot.writeFieldBegin('bitrate_err', TType.STRUCT, 5)
      self.bitrate_err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class convert_asset_args:
  """
  Attributes:
   - document_id
   - mimetype
   - conversion_info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'document_id', None, None, ), # 1
    (2, TType.STRING, 'mimetype', None, None, ), # 2
    (3, TType.MAP, 'conversion_info', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, document_id=None, mimetype=None, conversion_info=None,):
    self.document_id = document_id
    self.mimetype = mimetype
    self.conversion_info = conversion_info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.document_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mimetype = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.conversion_info = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.conversion_info[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('convert_asset_args')
    if self.document_id != None:
      oprot.writeFieldBegin('document_id', TType.STRING, 1)
      oprot.writeString(self.document_id)
      oprot.writeFieldEnd()
    if self.mimetype != None:
      oprot.writeFieldBegin('mimetype', TType.STRING, 2)
      oprot.writeString(self.mimetype)
      oprot.writeFieldEnd()
    if self.conversion_info != None:
      oprot.writeFieldBegin('conversion_info', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.conversion_info))
      for kiter7,viter8 in self.conversion_info.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class convert_asset_result:
  """
  Attributes:
   - success
   - asset_err
   - info_err
   - converter_err
   - mime_err
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'asset_err', (smaclib.api.errors.ttypes.AssetNotFound, smaclib.api.errors.ttypes.AssetNotFound.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'info_err', (smaclib.api.errors.ttypes.InvalidConversionInfo, smaclib.api.errors.ttypes.InvalidConversionInfo.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'mime_err', (smaclib.api.errors.ttypes.UnknownMimetype, smaclib.api.errors.ttypes.UnknownMimetype.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'converter_err', (smaclib.api.errors.ttypes.UnsupportedConversion, smaclib.api.errors.ttypes.UnsupportedConversion.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, asset_err=None, info_err=None, converter_err=None, mime_err=None,):
    self.success = success
    self.asset_err = asset_err
    self.info_err = info_err
    self.converter_err = converter_err
    self.mime_err = mime_err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.asset_err = smaclib.api.errors.ttypes.AssetNotFound()
          self.asset_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.info_err = smaclib.api.errors.ttypes.InvalidConversionInfo()
          self.info_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.converter_err = smaclib.api.errors.ttypes.UnsupportedConversion()
          self.converter_err.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.mime_err = smaclib.api.errors.ttypes.UnknownMimetype()
          self.mime_err.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('convert_asset_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.asset_err != None:
      oprot.writeFieldBegin('asset_err', TType.STRUCT, 1)
      self.asset_err.write(oprot)
      oprot.writeFieldEnd()
    if self.info_err != None:
      oprot.writeFieldBegin('info_err', TType.STRUCT, 2)
      self.info_err.write(oprot)
      oprot.writeFieldEnd()
    if self.mime_err != None:
      oprot.writeFieldBegin('mime_err', TType.STRUCT, 3)
      self.mime_err.write(oprot)
      oprot.writeFieldEnd()
    if self.converter_err != None:
      oprot.writeFieldBegin('converter_err', TType.STRUCT, 4)
      self.converter_err.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
